import {
  createAsyncThunk,
  createSlice,
  PayloadAction,
  Reducer,
} from "@reduxjs/toolkit";
import booleanContains from "@turf/boolean-contains"
import { lineString, point } from "@turf/helpers";

import { isUndefined } from "lodash";
import { getEventDataFromMockedApi } from "../api";
import { DeviceEvent } from "../types";
import { RootState } from "./store";
import fieldsJson from "../api/fields.json";

export interface DeviceEventsState {
  ids: number[];
  entities: { [id: number]: DeviceEvent };
  selectedId?: number;
  status?: "pending" | "fulfilled" | "rejected";
  mostRecentEvents: { [name: string]: DeviceEvent };
}

const initialState: DeviceEventsState = {
  ids: [],
  entities: [],
  mostRecentEvents: {},
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(fetchDeviceEvents())`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const fetchDeviceEvents = createAsyncThunk(
  "fetchDeviceEvents",
  async (): Promise<DeviceEvent[]> => {
    try {
      return await getEventDataFromMockedApi();
    } catch (e) {
      return Promise.reject(e);
    }
  }
);

export const deviceEvents = createSlice({
  name: "deviceEvents",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    clickDeviceEvent(state, action: PayloadAction<number>) {
      state.selectedId = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchDeviceEvents.pending, (state) => {
        state.status = "pending";
      })
      .addCase(fetchDeviceEvents.fulfilled, (state, action) => {
        state.status = "fulfilled";
        const initializer: DeviceEventsState = {
          ids: [],
          entities: {},
          mostRecentEvents: {},
        };
        const nextState = action.payload.reduce((accumulator, deviceEvent) => {
          return {
            ...accumulator,
            ids: [...accumulator.ids, deviceEvent.id],
            entities: {
              ...accumulator.entities,
              [deviceEvent.id]: {
                ...deviceEvent,
              },
            },
            mostRecentEvents: {
              ...accumulator.mostRecentEvents,
              [deviceEvent.device_alias]: {
                ...deviceEvent
                // TODO doesn't compare timestamps. Object is possibly 'undefined'.
                // ...((deviceEvent.event_timestamp > accumulator.mostRecentEvents[deviceEvent.device_alias].event_timestamp) && deviceEvent)
              }
            }
          };
        }, initializer);
        state.ids = nextState.ids;
        state.entities = nextState.entities;
        state.mostRecentEvents = nextState.mostRecentEvents;
      })
      .addCase(fetchDeviceEvents.rejected, (state) => {
        state.status = "rejected";
      });
  },
});

export const { clickDeviceEvent } = deviceEvents.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.deviceEvents.selectedId)`
export function getSelectedEventId(state: RootState): number | undefined {
  return state.deviceEvents.selectedId;
}

export const getAllDeviceEvents = (state: RootState): DeviceEvent[] => {
  return state.deviceEvents.ids.reduce<DeviceEvent[]>(function ensureDefined(
    acc,
    id
  ): DeviceEvent[] {
    const event = state.deviceEvents.entities[id];
    if (isUndefined(event)) {
      return acc;
    }
    return [...acc, event];
  },
  []);
};

/**
 * Gets most recent event from all devices located within a specified field
 *
 * @param {RootState} state - Contains DeviceEvents, Field Info, etc.
 * @param {string} fieldName - String of requested field
 * 
 * @returns {DeviceEvent[]} - All DeviceEvents inside of fieldName's polygons
 */
export function getMostRecentEventsPerField(state: RootState, fieldName: string): DeviceEvent[] | any {
  let returnArr = []
  for (let i = 0; i < fieldsJson.length; i++) {
    let polygonArr = []
    if (fieldsJson[i]?.field_name === fieldName) {
      // console.log(fieldsJson[i]?.polygon.coordinates)
      let line = lineString(fieldsJson[i]?.polygon.coordinates[0]) // TODO Argument of type 'number[][] | undefined' is not assignable to parameter of type 'Position[]'
      for (const [key, value] of Object.entries(state.deviceEvents.mostRecentEvents)) {
        // console.log("recentEvent", value.gps?.location?.coordinates)
        let eventPoint = point(value.gps?.location?.coordinates) // TODO Argument of type 'number[] | undefined' is not assignable to parameter of type 'Position'.
        if (booleanContains(line, eventPoint) === true) {
          polygonArr.push()
        } 
        // console.log("eventPoint", eventPoint)
      }
      // console.log("state", state.deviceEvents.mostRecentEvents)
      // console.log("line", line)
    }
    // for (let j = 0; j < fieldsJson[i]?.polygon.coordinates[0]?.length; j++) {
    //   polygonArr.push(new google.maps.LatLngLiteral)
    // }
    // let field = new google.maps.Polygon({
    //   paths: fieldsJson[i]?.polygon.coordinates[0]
    // });
    // console.log("field", field)
  }
  // PSEUDO BRAINSTORM
  // init arr that will contain all devices + events per field
  // find fieldname in fields.json.
  // convert field coordinates to google.maps.Polygon
  // iterate through state.MostRecentEvents and do google.maps.geometry.poly.containsLocation foreach
  // if true
}

const deviceEventsReducer: Reducer<DeviceEventsState> = deviceEvents.reducer;
export default deviceEventsReducer;
